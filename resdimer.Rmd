---
title: 'Resampled dimensional reduction for feature representation in machine 
        learning'
# author:
#   - name: Herdiantri Sufriyana
#     affiliation:
#     - &gibi Graduate Institute of Biomedical Informatics, College of Medical
#       Science and Technology, Taipei Medical University, Taipei, Taiwan
#     - Department of Medical Physiology, College of Medicine, University of
#       Nahdlatul Ulama Surabaya, Surabaya, Indonesia
#     email: herdiantrisufriyana@unusa.ac.id
#   - name: Yu-Wei Wu
#     affiliation:
#     - *gibi
#     - &tmuh Clinical Big Data Research Center, Taipei Medical University
#       Hospital, Taipei, Taiwan
#   - name: Emily Chia-Yu Su
#     affiliation:
#     - *gibi
#     - *tmuh
#     - Research Center for Artificial Intelligence in Medicine, Taipei Medical
#       University, Taipei, Taiwan
output: 
  # pdf_document
  word_document:
    reference_docx: styles_resdimer.docx
always_allow_html: yes
---

\tableofcontents
\newpage

# Introduction

In this Supplementary Information, we describe details on this study following 
chronological order of our analysis pipeline on data representation into new 
dimensions by resampling. We would use prelabor rupture of membranes (PROM) 
with 10-fold cross-validated principal components (PCs), as an example. There 
are three of six sections corresponding to some sections in the main text, 
which are respectively Introduction, Software and equipment, and Procedure. 
Along with this PDF document, we also provide R Markdown (.Rmd) containing the 
same texts with this document but including the programming codes for the data 
analysis in-between of these texts. The R Markdown are available in 
https://github.com/herdiantrisufriyana/resdimer. To get raw data, one need to 
request an access from the BPJS Kesehatan for their sample dataset published in 
August 2019. Up to this date, there are three sample datasets they published in 
February 2019, August 2019, and December 2020. For the first and second 
versions, a request is applied via https://e-ppid.bpjs-kesehatan.go.id/, while 
the third is applied via https://data.bpjs-kesehatan.go.id. To preprocess the 
raw data into the input dataset of this study, follow the codes of the R 
Markdown in 
https://github.com/herdiantrisufriyana/medhist/tree/main/preprocessing.

# Software and equipment

## Programming environment

We set up a programming environment for this study. Bioconductor was utilized 
as described in the main text. There were 123 R packages which are 8 base 
packages, 29 other packages, and 109 dependencies.

```{r Set up reproducible environment, include=FALSE}
if(!require(renv)) install.packages('renv')
if(!file.exists('renv')) renv::init(restart=F)
```

```{r Set sample kind, include=FALSE}
# sample.kind=NULL # if using R 3.5 or earlier
sample.kind='Rounding' # if using R 3.6 or later
```

```{r Set to run or not run very heavy computations, include=FALSE}
# Many computations were very heavy;
# thus, we provided the RDS files as substitutes and load only ones
# that can be ran in most computers.
# Set to TRUE if you want to run the very heavy computations.
run_heavy_computation=F
```

```{r Recommended memory limit, include=FALSE}
# Minimum 1 GB free memory should be allocated
memory.limit(size=1000000)
```

```{r Files not included in GitHub for some reasons, eval=FALSE, include=FALSE}
# Explicitly including data source
# Send a data access request to the BPJS Kesehatan. Use their data and our 
# preprocessing codes to get these files.

# data/public2.rds
# data/target_population.rds
# data/pregnancy_status.rds
# data/outcome.rds
# data/target_visits.rds
# data/annotation.rds
# data/mh_nationwide.rds
# data/mh_provider.rds
# data/cf_nationwide.rds
# data/cf_provider.rds
# data/inferdata.rds
# data/predidata.rds
# data/infercause.rds
# data/predicause.rds
# data/int_nps.rds

# Too large for GitHub (>25 mb)
# If one needs these files below, send email to herdiantrisufriyana@unusa.ac.id.

# data/pw_hlin.rds
# data/nw_int_hlin.rds
```

```{r Install and set specific version of Bioconductor, include=FALSE}
source('R/check_install_load-function.R')

# Install devtools to install specific version of BiocManager.
check_install_load('devtools',version='2.4.1',repo='cran',load=F)

# Install specific version of BiocManager and Bioconductor.
check_install_load('BiocManager',version='1.30.10',repo='cran',load=F)
install_steps=T
if(BiocManager::version()!='3.11'){
  BiocManager::install(version='3.11',update=TRUE,ask=FALSE)
  install_steps=c(F,T)
}
```

```{r Install and load packages with specific version, include=FALSE}
for(i in install_steps){
  check_install_load('tidyverse','1.3.0',repo='bioc',load=i)
  check_install_load('dslabs','0.7.3',repo='bioc',load=i)
  check_install_load('kableExtra','1.3.1',repo='bioc',load=i)
  check_install_load('parallel','4.0.2',repo='bioc',load=i)
  check_install_load('doParallel','1.0.16',repo='bioc',load=i)
  check_install_load('pbapply','1.4.3',repo='bioc',load=i)
  check_install_load('lubridate','1.7.9',repo='bioc',load=i)
  check_install_load('broom','0.7.3',repo='bioc',load=i)
  check_install_load('caret','6.0.86',repo='bioc',load=i)
  check_install_load('matrixStats','0.57.0',repo='bioc',load=i)
  check_install_load('Biobase','2.48.0',repo='bioc',load=i)
  check_install_load('medhist','0.1.0',repo='herdiantrisufriyana',load=i)
  check_install_load('rsdr','0.1.0',repo='herdiantrisufriyana',load=i)
  check_install_load('ggpubr','0.4.0',repo='bioc',load=i)
  check_install_load('extrafont','0.17',repo='bioc',load=i)
  check_install_load('ggsci','2.9',repo='bioc',load=i)
  check_install_load('readxl','1.3.1',repo='bioc',load=i)
  
  if(i){
    options(dplyr.summarise.inform=F)
    dslabs::ds_theme_set()
    select=dplyr::select
    rename=dplyr::rename
    slice=dplyr::slice
    renv::restore()
  }else{
    extrafont::font_import()
    renv::snapshot()
  }
}

rm(i)
```

```{r Load log for the expensive computation, include=FALSE}
# This is needed to print messages at the time we run the expensive computation.
source('data/log.R')
```

```{r Save package tables and the versions, eval=FALSE, include=FALSE}
rbind(
  
    # The base packages
    sessionInfo()$basePkgs %>%
      data.frame(
        package=.
        ,version=
          paste0(
            sessionInfo()$R.version$major
            ,'.'
            ,sessionInfo()$R.version$minor
          )
        ,base='Yes'
        ,loaded='Yes'
        ,attached='Yes'
      )
    
    # Additional packages specific to this study
    ,sessionInfo()$otherPkgs %>%
      lapply(function(x)data.frame(version=x$Version)) %>%
      do.call(rbind,.) %>%
      rownames_to_column(var='package') %>%
      mutate(base='No',loaded='Yes',attached='Yes')
    
    # The explicit dependencies
    ,sessionInfo()$loadedOnly %>%
      lapply(function(x)data.frame(version=x$Version)) %>%
      do.call(rbind,.) %>%
      rownames_to_column(var='package') %>%
      mutate(base='No',loaded='Yes',attached='No')
    
  ) %>%
  setNames(str_to_sentence(colnames(.))) %>%
  # group_by(Base,Loaded,Attached) %>%
  # summarize(n=n())

  kable() %>%
  kable_classic()
```

# Procedure

## Step 1

The data source was a sample dataset of the whole health insurance database 
during 2015 and 2016 by cross-sectional design. Stratified random sampling was 
applied. The strata variable was constructed from 66,072 combinations of all 
the healthcare facilities (*n*=22,024) and category of family, which were: (1) 
a family of which members never visit the healthcare facilities; (2) a family 
of which members have visited only primary care; and (3) a family of which 
members have visited all levels of care. For each stratum, one to ten families 
were randomly included. This means only 10 families were randomly included if 
more than that number, resulting 586,969 families with 1,697,452 subjects.

We conducted non-essential data cleaning, e.g. revising the inconsistent name 
of states, estimating the healthcare identifiers, *et cetera*. These procedures 
were parts of our R package of medhist 0.1.0. No sampling was conducted.

```{r Read public data II tables from an R file, eval=FALSE, include=FALSE}
# This is the output of the raw data after being preprocessed by data.Rmd in:
# https://github.com/herdiantrisufriyana/medhist/preprocessing
public=readRDS('data/public2.rds')
```

```{r Combine tables, eval=FALSE, include=FALSE}
public$visits=
  
  # Access a list of visit datasets based on capitation, fee for service (FFS), 
  # and diagnosis-related group (DRG).
  public[c('visit_cap','visit_ffs','visit_drg')] %>%
  
  # For each element of the list, select 4 columns and bind the elements by row.
  lapply(select,visit_id,subject_id,healthcare_id,admission_date) %>%
  do.call(rbind,.) %>%
  
  # Join with diagnosis dataset by visit_id, follow the dataframe above.
  left_join(public$diagnosis,by='visit_id') %>%
  
  # Exclude diagnoses at admission since it's unlikely definitive.
  filter(!code_type%in%c('Admission diagnosis')) %>%
  select(-code_type) %>%
  
  # Find the earliest visit per subject and filter only the unique visits.
  group_by(subject_id) %>%
  mutate(db_start_date=min(admission_date)) %>%
  ungroup() %>%
  filter(!duplicated(.))
```

After the non-essential data cleaning, we applied retrospective cohort design, 
as described in the main text. For pregnant women, we use several codes for 
determining delivery or immediately after delivery care. The 220 codes are 
described.

```{r Determine target population, eval=FALSE, include=FALSE}
public$target_population=
  
  ##### The health insurance holders of #####
  public$subject %>%
  lapply(X=1,Y=.,function(X,Y){
    # Record this step to the table of subject selection
    data.frame(
        step='total'
        ,exc_visit=0
        ,inc_visit=sum(public$visits$subject_id %in% Y$subject_id)
        ,exc_subject=0
        ,inc_subject=nrow(Y)
      ) %>%
      saveRDS('data/selection.rds')
    Y
  }) %>%
  .[[1]] %>%

  ##### 12-to-55-years-old (at visit between 2015 and 2016) #####
  filter(
    between(as.duration(as_date('2015-01-01')-birth_date)/dyears(1),12,55) |
    between(as.duration(as_date('2016-12-31')-birth_date)/dyears(1),12,55)
  ) %>%
  lapply(X=1,Y=.,function(X,Y){
    # Record this step to the table of subject selection.
    readRDS('data/selection.rds') %>%
      rbind(
        data.frame(
          step='age selection by 12 to 55 years old'
          ,exc_visit=
            .$inc_visit[nrow(.)]
            -sum(public$visits$subject_id %in% Y$subject_id)
          ,inc_visit=sum(public$visits$subject_id %in% Y$subject_id)
          ,exc_subject=.$inc_subject[nrow(.)]-nrow(Y)
          ,inc_subject=nrow(Y)
        )
      ) %>%
      saveRDS('data/selection.rds')
    Y
  }) %>%
  .[[1]] %>%

  ##### females #####
  filter(sex=='female') %>%
  lapply(X=1,Y=.,function(X,Y){
    # Record this step to the table of subject selection.
    readRDS('data/selection.rds') %>%
      rbind(
        data.frame(
          step='sex selection by female'
          ,exc_visit=
            .$inc_visit[nrow(.)]
            -sum(public$visits$subject_id %in% Y$subject_id)
          ,inc_visit=sum(public$visits$subject_id %in% Y$subject_id)
          ,exc_subject=.$inc_subject[nrow(.)]-nrow(Y)
          ,inc_subject=nrow(Y)
        )
      ) %>%
      saveRDS('data/selection.rds')
    Y
  }) %>%
  .[[1]] %>%

  ##### who visit healthcare providers #####
  filter(subject_id%in%public$visits$subject_id) %>%
  lapply(X=1,Y=.,function(X,Y){
    # Record this step to the table of subject selection.
    readRDS('data/selection.rds') %>%
      rbind(
        data.frame(
          step='visit healthcare providers'
          ,exc_visit=
            .$inc_visit[nrow(.)]
            -sum(public$visits$subject_id %in% Y$subject_id)
          ,inc_visit=sum(public$visits$subject_id %in% Y$subject_id)
          ,exc_subject=.$inc_subject[nrow(.)]-nrow(Y)
          ,inc_subject=nrow(Y)
        )
      ) %>%
      saveRDS('data/selection.rds')
    Y
  }) %>%
  .[[1]]
```

```{r Determine pregnant women of target population, eval=FALSE, include=FALSE}
public$pregnancy_status=
  
  # Get pregnancy status of the target population.
  public$target_population %>%
  lapply(X=1,Y=.,Z=public$visits,K=public$annotation,function(X,Y,Z,K){
    
    # Use these regular expression for the target population
    # to find codes related to pregnancy.
    L=Z %>%
      filter(subject_id%in%Y$subject_id) %>%
      left_join(K,by='code') %>%
      filter(
        str_detect(
          str_to_lower(paste(code,desc))
          ,paste0(c(
              'obstet'
              ,'pregnan'
              ,'labou?r\\s+'
              ,'deliver'
              ,'cesar'
              ,'natal'
              ,'z3[3467]'
              ,'o\\d+'
            ),collapse='|')
        )
      )
    
    # From the pregnancy-related visits, find the earliest and the latest.
    M=L %>%
      group_by(subject_id) %>%
      summarize(
        preg_e=min(admission_date)
        ,preg_l=max(admission_date)
        ,.groups='drop'
      ) %>%
      ungroup()
    
    # Find the related codes for the end of pregnancy.
    N=L %>%
      
      # This may include the false-positive codes
      filter(
        str_detect(
          str_to_lower(paste(code,desc))
          ,paste0(c(
            'abort'
            ,'deliver'
            ,'cesar'
            ,'labou?r\\s+'
            ,'natal'
            ,'postpartum'
            ,'terminat'
            ,'o0[0123]'
            ,'o152'
            ,'o364'
            ,'o63'
            ,'o7[02]'
            ,'o8[579]'
            ,'o90'
            ,'z3[79]'
          ),collapse='|')
        )
      ) %>%
      
      # By manual inspection, exclude the false-positive codes.
      filter(!(
        str_detect(
          str_to_lower(paste(code,desc))
          ,paste0(c(
            'aborter'
            ,'ante'
            ,'peri'
            ,'delayed'
            ,'false'
            ,'failed'
            ,'prenatal'
            ,'threatened'
            ,'o311'
            ,'z351'
            ,'o600'
            ,'o96'
          ),collapse='|')
        ) &
        !str_detect(
          str_to_lower(code)
          ,paste0(c(
            'o0[34568]'
            ,'o15[12]'
            ,'o7[02]'
            ,'o8[79]'
          ),collapse='|')
        )
      )) %>%
      
      # Record the codes for the end of pregnancy. 
      lapply(X=1,Y=.,function(X,Y){
        saveRDS(Y,'data/termination_codes.rds')
        Y
      }) %>%
      .[[1]] %>%
      
      # Find the earliest and latest dates of 
      # the related codes for  the end of pregnancy.
      group_by(subject_id) %>%
      summarize(
        termin_e=min(admission_date)
        ,termin_l=max(admission_date)
        ,.groups='drop'
      ) %>%
      ungroup()
    
    # Get visits after the end of the first pregnancy in the dataset period.
    O=L %>%
      left_join(N,by='subject_id') %>%
      filter(admission_date>termin_l)
    
    # Get the earliest date of the second-pregnancy visits.
    P=O %>%
      group_by(subject_id) %>%
      summarize(
        preg_e2=min(admission_date)
        ,.groups='drop'
      ) %>%
      ungroup()
    
    # Find the related codes for the end of the second pregnancy.
    Q=O %>%
      
      # This may include the false-positive codes
      filter(
        str_detect(
          str_to_lower(paste(code,desc))
          ,paste0(c(
            'abort'
            ,'deliver'
            ,'cesar'
            ,'labou?r\\s+'
            ,'natal'
            ,'postpartum'
            ,'terminat'
            ,'o0[0123]'
            ,'o152'
            ,'o364'
            ,'o63'
            ,'o7[02]'
            ,'o8[579]'
            ,'o90'
            ,'z3[79]'
          ),collapse='|')
        )
      ) %>%
      
      # By manual inspection, exclude the false-positive codes.
      filter(!(
        str_detect(
          str_to_lower(paste(code,desc))
          ,paste0(c(
            'aborter'
            ,'ante'
            ,'peri'
            ,'delayed'
            ,'false'
            ,'failed'
            ,'prenatal'
            ,'threatened'
            ,'o311'
            ,'z351'
            ,'o600'
            ,'o96'
          ),collapse='|')
        ) &
        !str_detect(
          str_to_lower(code)
          ,paste0(c(
            'o0[34568]'
            ,'o15[12]'
            ,'o7[02]'
            ,'o868'
            ,'o8[79]'
          ),collapse='|')
        )
      )) %>%
      
      # Find the earliest and latest dates of 
      # the related codes for  the end of the second pregnancy.
      group_by(subject_id) %>%
      summarize(
        termin_e2=suppressWarnings(min(admission_date))
        ,termin_l2=suppressWarnings(max(admission_date))
        ,.groups='drop'
      ) %>%
      ungroup()
    
    # Join offset dates to find the pregnancy periods.
    R=M %>%
      left_join(N,by='subject_id') %>%
      left_join(P,by='subject_id') %>%
      left_join(Q,by='subject_id') %>%
      select(
        subject_id
        ,preg_e
        ,termin_e
        ,termin_l
        ,preg_e2
        ,termin_e2
        ,termin_l2
        ,preg_l
        ,everything()
      )
    
    # Join the offset dates to the target population data
    # and compute the number of either gestation and termination.
    S=Y %>%
      left_join(R,by='subject_id') %>%
      mutate(
        gestation=
          as.integer(!is.na(preg_e))
          + as.integer(!is.na(preg_e2))
        ,termination=
          as.integer(!is.na(termin_l))
          + as.integer(!is.na(termin_l2))
      )
    
    # Filtered by gestation, select different offsets depending on
    # the pregnancy period, and combine the filtering results. 
    # This separates 2 pregnancy periods of a subject into 2 instances.
    rbind(
        filter(S,gestation==0) %>%
          select(
            subject_id,preg_e,termin_e,termin_l,preg_l,gestation,termination
          ) %>%
          mutate(gestation_n=0)
        ,filter(S,gestation==1) %>%
          select(
            subject_id,preg_e,termin_e,termin_l,preg_l,gestation,termination
          ) %>%
          mutate(gestation_n=1)
        ,filter(S,gestation==2) %>%
          select(
            subject_id,preg_e,termin_e,termin_l,preg_l,gestation,termination
          ) %>%
          mutate(gestation_n=1)
        ,filter(S,gestation==2) %>%
          select(
            subject_id,preg_e2,termin_e2,termin_l2,preg_l,gestation,termination
          ) %>%
          rename(preg_e=preg_e2,termin_e=termin_e2,termin_l=termin_l2) %>%
          mutate(gestation_n=2)
      ) %>%
      
      # If no termination for a pregnancy period of a subject,
      # then label the period as having censored outcome.
      mutate(censoring=is.na(termin_l)) %>%
      
      # Join to the target population data and arranged by subject_id
      left_join(
        S %>%
          select(
            -preg_e
            ,-termin_e
            ,-termin_l
            ,-preg_e2
            ,-termin_e2
            ,-termin_l2
            ,-preg_l
            ,-gestation
            ,-termination
          )
        ,by='subject_id'
      ) %>%
      arrange(
        factor(subject_id,S$subject_id %>% .[!duplicated(.)])
      )
    
  }) %>%
  .[[1]]
```

```{r Save termination codes as CSV, eval=FALSE, include=FALSE}
readRDS('data/termination_codes.rds') %>%
  
  # By manual inspection, check the termination codes.
  select(code,desc) %>%
  filter(!duplicated(.)) %>%
  arrange(code) %>%
  
  kable() %>%
  kable_classic()
```

```{r Determine outcome, eval=FALSE, include=FALSE}
public$outcome=
  
  # Filter visits from the target population only.
  public$visits %>%
  filter(subject_id %in% public$target_population$subject_id) %>%
  
  # Extract outcome, which is O42.
  extract_outcome(
    icd10_event='O42'
    ,latest_event=min
    ,day_to_event=0
    ,icd10_nonevent=''
    ,latest_nonevent=max
    ,day_to_nonevent=0
    ,verbose=0
  ) %>%
  
  # Join the pregnancy status data to the outcome data.
  left_join(public$pregnancy_status,by='subject_id') %>%
  
  # If non-event, the latest date should be 
  # the earliest date of the end of pregnancy.
  lapply(X=1,Y=.,function(X,Y){
    Z=Y %>%
      filter(!censoring & outcome=='nonevent') %>%
      mutate(latest_date=termin_e)
    K=Y %>%
      filter(!(!censoring & outcome=='nonevent'))
    rbind(Z,K) %>%
      arrange(factor(subject_id,unique(Y$subject_id)))
  }) %>%
  .[[1]] %>%
  
  # Get only column to filter visits before the outcome 
  # for each pregnancy episode.
  select(subject_id,latest_date,outcome,censoring,gestation_n)
```

```{r Determine target visits, eval=FALSE, include=FALSE}
public$target_visits=
  
  # Join the outcome data to the visit data.
  public$outcome %>%
  right_join(public$visits,by='subject_id') %>%
  select(visit_id, everything()) %>%
  
  # If the outcome is censored, take visits up to the outcome date.
  # Otherwise, take all visits.
  filter(!is.na(censoring)) %>%
  filter(censoring | (!censoring & admission_date<=latest_date)) %>%
  mutate(code=ifelse(is.na(code)|code=='','NA',code)) %>%
  
  # Take only codes that are available 
  # in all combinations of outcome and censoring status.
  lapply(X=1,Y=.,function(X,Y){
    Z=Y %>%
      select(outcome,censoring,code) %>%
      filter(!duplicated(.)) %>%
      mutate(count=1) %>%
      group_by(code) %>%
      summarize(count=sum(count)) %>%
      arrange(desc(count)) %>%
      filter(count==4) %>%
      pull(code)
    
    Y %>% filter(code%in%Z)
  }) %>%
  .[[1]] %>%
  
  # Take needed columns and make subject_id different 
  # between pregnancy episodes of the same subject.
  select(-censoring,-outcome,-latest_date) %>%
  unite(subject_id,subject_id,gestation_n,sep='.')
```

```{r Update related variables, eval=FALSE, include=FALSE}
# Take only subjects' outcome that are assigned to the target visits.
public$outcome2=
  public$outcome %>%
  unite(subject_id,subject_id,gestation_n,sep='.') %>%
  filter(subject_id%in%public$target_visits$subject_id)

# Take only subjects' pregnancy status that are assigned to the target visits.
public$pregnancy_status2=
  public$pregnancy_status %>%
  unite(subject_id,subject_id,gestation_n,sep='.') %>%
  filter(subject_id%in%public$target_visits$subject_id)

# Add more criterion to the target population.
public$target_population2=
  
  public$target_population %>%
  left_join(
    select(public$pregnancy_status,subject_id,gestation_n)
    ,by=c('subject_id')
  ) %>%
  unite(subject_id,subject_id,gestation_n,sep='.') %>%
  
  ##### before the latest date of event/non-event #####
  ##### and split if >1 pregnancies #####
  filter(subject_id%in%public$target_visits$subject_id) %>%
  lapply(X=1,Y=.,function(X,Y){
    # Record this step to the table of subject selection.
    step_desc='up to the latest date for uncensored and split if >1 pregnancies'
    readRDS('data/selection.rds') %>%
      filter(step!=step_desc) %>%
      rbind(
        data.frame(
          step=step_desc
          ,exc_visit=
            .$inc_visit[nrow(.)]
            -sum(public$target_visits$subject_id %in% Y$subject_id)
          ,inc_visit=sum(public$target_visits$subject_id %in% Y$subject_id)
          ,exc_subject=.$inc_subject[nrow(.)]-nrow(Y)
          ,inc_subject=nrow(Y)
        )
      ) %>%
      saveRDS('data/selection.rds')
    Y
  }) %>%
  .[[1]]
```

```{r Describe selection results for sanity check, eval=FALSE, include=FALSE}
readRDS('data/selection.rds') %>%
  kable() %>%
  kable_classic()
```

```{r Describe pregnancy status, eval=FALSE, include=FALSE}
public$pregnancy_status %>%
  
  # Summarize the number and proportion of subjects with 0 to 2 gestation.
  select(subject_id,gestation) %>%
  filter(!duplicated(.)) %>%
  group_by(gestation) %>%
  summarize(n=n(),.groups='drop') %>%
  mutate(p=n/sum(n)) %>%
  
  # Join to compare with the subjects' pregnancy status 
  # that are assigned to the target visits.
  left_join(
    public$pregnancy_status2 %>%
      separate(subject_id,c('subject_id','gestation_n'),sep='\\.') %>%
      select(subject_id,gestation) %>%
      filter(!duplicated(.)) %>%
      group_by(gestation) %>%
      summarize(n2=n(),.groups='drop') %>%
      mutate(p2=n2/sum(n2))
    ,by='gestation'
  ) %>%
  kable() %>%
  kable_classic()
```

```{r Describe outcome per pregnancy status, eval=FALSE, include=FALSE}
public$pregnancy_status %>%
  
  # Join the ourcome data to the pregnancy status data.
  left_join(public$outcome,by=c('subject_id','gestation_n','censoring')) %>%
  
  # Summarize the number and proportion of subjects 
  # by combination of censoring status, outcome, and number of gestation.
  group_by(gestation_n,outcome,censoring) %>%
  summarize(n=n(),.groups='drop') %>%
  mutate(p=n/sum(n)) %>%
  
  # Join to compare with the subjects' pregnancy status 
  # that are assigned to the target visits.
  left_join(
    public$pregnancy_status2 %>%
      separate(subject_id,c('subject_id','gestation_n'),sep='\\.') %>%
      left_join(
        public$outcome2 %>%
          separate(subject_id,c('subject_id','gestation_n'),sep='\\.')
        ,by=c('subject_id','gestation_n','censoring')
      ) %>%
      mutate(gestation_n=as.numeric(gestation_n)) %>%
      group_by(gestation_n,outcome,censoring) %>%
      summarize(n2=n(),.groups='drop') %>%
      mutate(p2=n2/sum(n2))
    ,by=c('gestation_n','outcome','censoring')
  ) %>%
  kable() %>%
  kable_classic()
```

```{r Save selection results to RDS file, eval=FALSE, include=FALSE}
saveRDS(public$target_population2,'data/target_population.rds')
saveRDS(public$pregnancy_status2,'data/pregnancy_status.rds')
saveRDS(public$outcome2,'data/outcome.rds')
saveRDS(public$target_visits,'data/target_visits.rds')
saveRDS(public$annotation,'data/annotation.rds')
```

```{r Remove public data II after selection, eval=FALSE, include=FALSE}
rm(public)
```

We conducted data preprocessing after defining the target population and 
sampling it retrospectively. Demographics were included as categorical 
variables for causal factor we used as variable of interests. Then, We computed 
a number of days for a code, or any code representing a causal factor, in the 
latest encounter before each visit.

```{r Load an outcome table, include=FALSE}
outcome=
  readRDS('data/outcome.rds') %>%
  left_join(
    readRDS('data/pregnancy_status.rds')
    ,by=c('subject_id','censoring')
  ) %>%
  rename(reghc_id=healthcare_id)
```

```{r Visits with categorical identity as additional variables, include=FALSE}
visit_cip=
  
  # Transform age into a categorical variable based on domain knowledge.
  outcome %>%
  mutate(
    age=case_when(
      ((latest_date-birth_date)/dyears(1))<20~'Too Young'
      ,(((latest_date-birth_date)/dyears(1))>=20 &
        ((latest_date-birth_date)/dyears(1))<=35)
       ~'Low Risk'
      ,((latest_date-birth_date)/dyears(1))>35~'Too Old'
      ,TRUE~'NA'
    )
  ) %>%
  
  # Select subject_id and all categorical variables (not medical history).
  select(subject_id,age,marital_status,insurance_class,occupation_segment) %>%
  gather(variable,value,-subject_id) %>%
  unite(desc,variable,value,sep='_') %>%
  mutate(desc=str_replace_all(desc,'_|-|\\s',' ')) %>%
  separate(desc,c('first_word','desc'),sep=' ',extra='merge') %>%
  mutate_at('first_word',str_to_sentence) %>%
  unite(desc,first_word,desc,sep=' ') %>%
  
  # Create a code for each category.
  lapply(X=1,Y=.,function(X,Y){
    select(.,desc) %>%
      filter(!duplicated(.)) %>%
      
      # Create a code for each categorical variable.
      mutate(code=sapply(desc,function(x){
        str_split(x,'\\s')[[1]] %>%
          substr(1,1) %>%
          paste(collapse='') %>%
          str_to_upper()
      })) %>%
      
      # For each code, assign number to non-single code.
      group_by(code) %>%
      mutate(code_seq=seq(n()),max_code_seq=n()) %>%
      ungroup() %>%
      unite(code2,code,code_seq,sep='',remove=F) %>%
      mutate(code=ifelse(max_code_seq==1,code,code2)) %>%
      
      # Save all categorical variables and the codes.
      select(code,desc) %>%
      saveRDS('data/cat_identity.rds')
    Y
  }) %>%
  .[[1]] %>%
  
  # Join the codes of the categorical variables.
  left_join(readRDS('data/cat_identity.rds'),by='desc') %>%
  
  # Join the target visits.
  left_join(
    readRDS('data/target_visits.rds') %>%
      select(-code) %>%
      mutate(seq=seq(nrow(.))) %>%
      select(seq,everything())
    ,by='subject_id'
  ) %>%
  
  # Select columns according to the standard for medhist.
  select(
    seq
    ,visit_id
    ,subject_id
    ,healthcare_id
    ,admission_date
    ,code
    ,db_start_date
  ) %>%
  
  # Add the categorical variables as if these are diagnosis/procedure codes 
  # of which dates are the dates of any codes in a visit of a subject.
  rbind(
    readRDS('data/target_visits.rds') %>%
      mutate(seq=seq(nrow(.))) %>%
      select(seq,everything())
  )
```

```{r Convenient sampling from an authoritative, include=FALSE}
convenient_sampling=
  matrix(
    c('variable'
      ,'PROM'
      ,'Preterm birth'
      ,'Multiple pregnancy'
      ,'IAI'
      ,'Previous PROM'
      ,'Cervical shortening'
      ,'APH'
      ,'Low BMI'
      ,'Low SES'
      ,'Cigarette smoking'
      ,'Illicit drug use'
    )
    ,ncol=1,byrow=T
  ) %>%
  `colnames<-`(.[1,]) %>%
  .[-1,,drop=F] %>%
  as.data.frame()
```

```{r Determine measurement of causal factors, include=FALSE}
# Outcome with the causal factors based on prior knowledge
baseline_nodes=
  matrix(
    c('name','label'
      ,'PROM','Y01'
      ,'Multiple pregnancy','A02'
      ,'Chorioamnionitis','A03'
      ,'IAI','A04'
      ,'APH','A06'
      ,'GTI','A10'
      ,'Periodontal disease','A11'
      ,'Pneumonia','A13'
      ,'Asthma','A15'
      ,'Low SES','A19'
      ,'Maternal age','A20'
      ,'Influenza','A28'
      )
    ,ncol=2,byrow=T
  ) %>%
  `colnames<-`(.[1,]) %>%
  .[-1,] %>%
  as.data.frame()
# Define components of each causal factor by ICD-10 coding.
measure_nodes=
  baseline_nodes %>%
  mutate(
    regex=case_when(
      name=='PROM'~'O42'
      ,name=='Multiple pregnancy'~'O3[01]'
      ,name=='Chorioamnionitis'~'O411'
      ,name=='IAI'~'O41[89]'
      ,name=='APH'~'O46'
      ,name=='GTI'~'914[139]|A6[03]|O23[59]|R87'
      ,name=='Periodontal disease'~'K05'
      ,name=='Pneumonia'~'J1[23458]'
      ,name=='Asthma'~'J4[56]'
      ,name=='Low SES'~'THIRD|UNEMPLOYED'
      ,name=='Maternal age'~'TOO YOUNG|TOO OLD'
      ,name=='Influenza'~'J(00|09|10|11)'
      ,TRUE~''
    )
  ) %>%
  filter(regex!='') %>%
  lapply(X=seq(nrow(.)),Y=.,function(X,Y){
    data.frame(name=Y$regex[X],label=paste0(Y$label[X],'*'))
  }) %>%
  do.call(rbind,.)
```

```{r Compute nationwide day interval of medical history, include=FALSE}
if(run_heavy_computation){
  mh_nationwide=
    readRDS('data/target_visits.rds') %>%
    mutate(healthcare_id='nationwide') %>%
    extract_medical_history(cl=detectCores()-1)
  saveRDS(mh_nationwide,'data/mh_nationwide.rds')
}else{
  cat(readRDS('data/log.rds')[['mh_nationwide']])
  mh_nationwide=readRDS('data/mh_nationwide.rds')
}
```

```{r Compute provider-wise day interval of medical history, include=FALSE}
if(run_heavy_computation){
  mh_provider=
    readRDS('data/target_visits.rds') %>%
    extract_medical_history(cl=detectCores()-1)
  saveRDS(mh_provider,'data/mh_provider.rds')
}else{
  cat(readRDS('data/log.rds')[['mh_provider']])
  mh_provider=readRDS('data/mh_provider.rds')
}
```

```{r Compute nationwide day interval of causal factor, include=FALSE}
if(run_heavy_computation){
  cf_nationwide=
    
    # Exclude outcome.
    measure_nodes %>%
    filter(label!='Y01*') %>%
    
    # For each causal factor, filter rows with the codes related to the factor 
    # regardless the healthcare facilities.
    lapply(X=seq(nrow(.))
           ,Y=.
           ,Z=
             visit_cip %>%
             mutate(healthcare_id='nationwide') %>%
             left_join(
               readRDS('data/cat_identity.rds') %>%
                 rbind(annotation)
               ,by='code'
             )
           ,function(X,Y,Z){
      
      if(Y$label[X]%in%c('A19*','A20*')){
        K=Z %>%
          filter(!str_detect(str_to_upper(code),'[:digit:]')) %>%
          filter(str_detect(str_to_upper(desc),Y$name[X]))
      }else{
        K=Z %>% filter(str_detect(str_to_upper(code),Y$name[X]))
      }
      
      K %>%
        select(-desc) %>%
        mutate(
          code=
            Y$label[X] %>%
            str_remove_all('\\*')
        )
      
    }) %>%
    do.call(rbind,.) %>%
    filter(!duplicated(.)) %>%
    select(-seq) %>%
    
    # Extract the day intervals.
    extract_medical_history(cl=detectCores()-1) %>%
    filter(!duplicated(.)) %>%
    
    # Join to the target visits.
    right_join(
      readRDS('data/target_visits.rds') %>%
        select(-code) %>%
        mutate(healthcare_id='nationwide')
      ,by=c('visit_id'
            ,'subject_id'
            ,'healthcare_id'
            ,'admission_date'
            ,'db_start_date')
    ) %>%
    select(
      visit_id
      ,subject_id
      ,healthcare_id
      ,admission_date
      ,db_start_date
      ,everything()
    )
  
  saveRDS(cf_nationwide,'data/cf_nationwide.rds')
}else{
  cat(readRDS('data/log.rds')[['cf_nationwide']])
  cf_nationwide=readRDS('data/cf_nationwide.rds')
}
```

```{r Compute provider-wise day interval of causal factor, include=FALSE}
if(run_heavy_computation){
  cf_provider=
    
    # Exclude outcome.
    measure_nodes %>%
    filter(label!='Y01*') %>%
    
    # For each causal factor, filter rows with the codes related to the factor 
    # in each of the healthcare facilities.
    lapply(X=seq(nrow(.))
           ,Y=.
           ,Z=
             visit_cip %>%
             left_join(
               readRDS('data/cat_identity.rds') %>%
                 rbind(annotation)
               ,by='code'
             )
           ,function(X,Y,Z){
      
      if(Y$label[X]%in%c('A19*','A20*')){
        K=Z %>%
          filter(!str_detect(str_to_upper(code),'[:digit:]')) %>%
          filter(str_detect(str_to_upper(desc),Y$name[X]))
      }else{
        K=Z %>% filter(str_detect(str_to_upper(code),Y$name[X]))
      }
      
      K %>%
        select(-desc) %>%
        mutate(
          code=
            Y$label[X] %>%
            str_remove_all('\\*')
        )
      
    }) %>%
    do.call(rbind,.) %>%
    filter(!duplicated(.)) %>%
    select(-seq) %>%
    
    # Extract the day intervals.
    extract_medical_history(cl=detectCores()-1) %>%
    filter(!duplicated(.)) %>%
    
    # Join to the target visits.
    right_join(
      readRDS('data/target_visits.rds') %>%
        select(-code)
      ,by=c('visit_id'
            ,'subject_id'
            ,'healthcare_id'
            ,'admission_date'
            ,'db_start_date')
    ) %>%
    select(
      visit_id
      ,subject_id
      ,healthcare_id
      ,admission_date
      ,db_start_date
      ,everything()
    )
  
  saveRDS(cf_provider,'data/cf_provider.rds')
}else{
  cat(readRDS('data/log.rds')[['cf_provider']])
  cf_provider=readRDS('data/cf_provider.rds')
}
```

```{r Sanity check for the number of visits and subjects, include=FALSE}
source('R/outcome_visit_subject-function.R')
```

```{r Show sanity check results, eval=FALSE, include=FALSE}
rbind(
    readRDS('data/target_visits.rds') %>%
      left_join(readRDS('data/outcome.rds'),by='subject_id') %>%
      outcome_visit_subject('original')
    
    ,mh_nationwide %>%
      left_join(readRDS('data/outcome.rds'),by='subject_id') %>%
      outcome_visit_subject('nationwide')
    
    ,mh_provider %>%
      left_join(readRDS('data/outcome.rds'),by='subject_id') %>%
      outcome_visit_subject('provider')
    
    ,cf_nationwide %>%
      left_join(readRDS('data/outcome.rds'),by='subject_id') %>%
      outcome_visit_subject('nationwide, causal')
    
    ,cf_provider %>%
      left_join(readRDS('data/outcome.rds'),by='subject_id') %>%
      outcome_visit_subject('provider, causal')
  ) %>%
  kable() %>%
  kable_classic()
```

```{r Build a function to personalize PROM tidy set, include=FALSE}
source('R/prom_tidyset_personalization-function.R')
```

To ensure PCs defined by derivation set only, we need to conduct data partition 
before continuing the downstream analysis. Therefore, PCs were not derived by 
involving validation set.

```{r Build a function to split for external validation, include=FALSE}
source('R/extv-function.R')
```

```{r Compile tidy sets followed by data partitioning, include=FALSE}
if(run_heavy_computation){
  
  # Nationwide data for inference by medical histories with splitting 
  # information for external validation
  inferdata=
    mh_nationwide %>%
    compile_mh_outcome(select(outcome,subject_id,latest_date,outcome)) %>%
    prom_tidyset_personalization(
      outcome=outcome
      ,experimenter=
        MIAME(
          name='Herdiantri Sufriyana'
          ,lab='Emily Chia-Yu Su Lab'
          ,contact='herdiantrisufriyana@unusa.ac.id'
          ,title='Medical history dataset for causal inference'
          ,abstract=
            str_replace_all(
              'This dataset is a medical-history table from the BPJS Kesehatan.
              The target population is health insurance holders of 
              12-to-55-years-old females who visit healthcare providers between 
              2015 and 2016. The outcome of interest is prelabor rupture of 
              membrane (PROM). The medical history scenario is recorded across
              healthcare providers nationwide.'
              ,'\n',' '
            ) %>%
            str_replace_all('\\s+',' ')
          ,url='https://github.com/herdiantrisufriyana/prom'
        )
      ,annotation=readRDS('data/annotation.rds')
    ) %>%
    extv(geo_p=0.12,tem_p=0.35,bgt_p=1,ran_p=0.2)
  saveRDS(inferdata,'data/inferdata.rds')
  
  # Provider-wise data for prediction by medical histories with splitting 
  # information for external validation
  predidata=
    mh_provider %>%
    compile_mh_outcome(select(outcome,subject_id,latest_date,outcome)) %>%
    prom_tidyset_personalization(
      outcome=outcome
      ,experimenter=
        MIAME(
          name='Herdiantri Sufriyana'
          ,lab='Emily Chia-Yu Su Lab'
          ,contact='herdiantrisufriyana@unusa.ac.id'
          ,title='Medical history dataset for prediction'
          ,abstract=
            str_replace_all(
              'This dataset is a medical-history table from the BPJS Kesehatan.
              The target population is health insurance holders of 
              12-to-55-years-old females who visit healthcare providers between 
              2015 and 2016. The outcome of interest is prelabor rupture of 
              membrane (PROM). The medical history scenario is recorded
              individually within each healthcare provider nationwide.'
              ,'\n',' '
            ) %>%
            str_replace_all('\\s+',' ')
          ,url='https://github.com/herdiantrisufriyana/prom'
        )
      ,annotation=readRDS('data/annotation.rds')
    ) %>%
    extv(geo_p=0.12,tem_p=0.35,bgt_p=1,ran_p=0.2)
  saveRDS(predidata,'data/predidata.rds')
  
  # Nationwide data for inference by causal factors with splitting information 
  # for external validation
  infercause=
    cf_nationwide %>%
    compile_mh_outcome(select(outcome,subject_id,latest_date,outcome)) %>%
    prom_tidyset_personalization(
      outcome=outcome
      ,experimenter=
        MIAME(
          name='Herdiantri Sufriyana'
          ,lab='Emily Chia-Yu Su Lab'
          ,contact='herdiantrisufriyana@unusa.ac.id'
          ,title='Medical history dataset for causal inference'
          ,abstract=
            str_replace_all(
              'This dataset is a medical-history table from the BPJS Kesehatan.
              The codes are re-assigned into causal factors (defined by regex).
              The target population is health insurance holders of 
              12-to-55-years-old females who visit healthcare providers between 
              2015 and 2016. The outcome of interest is prelabor rupture of 
              membrane (PROM). The medical history scenario is recorded across
              healthcare providers nationwide.'
              ,'\n',' '
            ) %>%
            str_replace_all('\\s+',' ')
          ,url='https://github.com/herdiantrisufriyana/prom'
        )
      ,annotation=
        measure_nodes %>%
        mutate(label=str_remove_all(label,'\\*')) %>%
        rename(code=label,desc=name) %>%
        select(code,desc)
    ) %>%
    extv(geo_p=0.12,tem_p=0.35,bgt_p=1,ran_p=0.2)
  saveRDS(infercause,'data/infercause.rds')
  
  # Provider-wise data for prediction by causal factors with splitting 
  # information for external validation
  predicause=
    cf_provider %>%
    compile_mh_outcome(select(outcome,subject_id,latest_date,outcome)) %>%
    prom_tidyset_personalization(
      outcome=outcome
      ,experimenter=
        MIAME(
          name='Herdiantri Sufriyana'
          ,lab='Emily Chia-Yu Su Lab'
          ,contact='herdiantrisufriyana@unusa.ac.id'
          ,title='Medical history dataset for prediction'
          ,abstract=
            str_replace_all(
              'This dataset is a medical-history table from the BPJS Kesehatan.
              The codes are re-assigned into causal factors (defined by regex).
              The target population is health insurance holders of 
              12-to-55-years-old females who visit healthcare providers between 
              2015 and 2016. The outcome of interest is prelabor rupture of 
              membrane (PROM). The medical history scenario is recorded
              individually within each healthcare provider nationwide.'
              ,'\n',' '
            ) %>%
            str_replace_all('\\s+',' ')
          ,url='https://github.com/herdiantrisufriyana/prom'
        )
      ,annotation=
        measure_nodes %>%
        mutate(label=str_remove_all(label,'\\*')) %>%
        rename(code=label,desc=name) %>%
        select(code,desc)
    ) %>%
    extv(geo_p=0.12,tem_p=0.35,bgt_p=1,ran_p=0.2)
  saveRDS(predicause,'data/predicause.rds')
  
}else{
  inferdata=readRDS('data/inferdata.rds')
  predidata=readRDS('data/predidata.rds')
  infercause=readRDS('data/infercause.rds')
  predicause=readRDS('data/predicause.rds')
}
```

```{r Show data partition, eval=FALSE, include=FALSE}
inferdata %>%
  lapply(X=1,Y=.,function(X,Y){
    
    # Use phenotype and protocol data.
    cbind(
        pData(phenoData(Y))
        ,pData(protocolData(Y))
      ) %>%
      separate(subject_id,c('subject_id','gestation_n'),sep='\\.') %>%
      select(gestation_n,outcome,censoring,geo,tem,bgt,ran,int) %>%
      gather(partition,value,-gestation_n,-outcome,-censoring) %>%
      filter(value) %>%
      
      # Summarize number of instances 
      # by outcome, censoring status, and partition.
      group_by(gestation_n,outcome,censoring,partition) %>%
      summarize(n=n(),.groups='drop') %>%
      
      # Compute the statistics.
      group_by(partition) %>%
      mutate(subtotal=sum(n)) %>%
      ungroup() %>%
      mutate(total=ncol(Y)) %>%
      mutate(p=subtotal/total) %>%
      
      # Wrap up.
      select(partition,subtotal,total,p) %>%
      filter(!duplicated(.)) %>%
      arrange(factor(partition,c('int','ran','geo','tem','bgt')))
  }) %>%
  .[[1]] %>%
  kable() %>%
  kable_classic()
```

Deriving PCs is relatively time-consuming. If one eventually uses this method 
for predictive modeling, it is efficient to conduct any filtering of predictors 
and data transformation before derivation of PCs. Therefore, more time can 
be saved and one may not need to run expensive computation.

All candidate predictors, including non-demographical causal factors, have 
non-zero variances. There were 460 candidate predictors fulfilling this 
criterion. We also showed in the same table that there are 426 candidate 
predictors without perfect separation.

```{r Combine selected causal factors and medical histories, include=FALSE}
# Nationwide data for inference by causal factors,
# confirmed by IPW, and by medical histories
inferboth=
  ExpressionSet(
    assayData=
      rbind(
        exprs(infercause) %>%
          `rownames<-`(paste0('causal_',rownames(.)))
        ,exprs(inferdata)
      )
    ,phenoData=phenoData(inferdata)
    ,featureData=
      rbind(
        fData(infercause) %>%
          `rownames<-`(paste0('causal_',rownames(.)))
        ,fData(inferdata)
      ) %>%
      AnnotatedDataFrame(varMetadata=fvarMetadata(inferdata))
    ,experimentData=
      MIAME(
        name='Herdiantri Sufriyana'
        ,lab='Emily Chia-Yu Su Lab'
        ,contact='herdiantrisufriyana@unusa.ac.id'
        ,title='Medical history dataset for causal inference'
        ,abstract=
          str_replace_all(
            'This dataset is a medical-history table from the BPJS Kesehatan.
            Selected causal factors, that is re-assigned by regex, are added.
            The target population is health insurance holders of 
            12-to-55-years-old females who visit healthcare providers between 
            2015 and 2016. The outcome of interest is prelabor rupture of 
            membrane (PROM). The medical history scenario is recorded
            individually within each healthcare provider nationwide.'
            ,'\n',' '
          ) %>%
          str_replace_all('\\s+',' ')
        ,url='https://github.com/herdiantrisufriyana/prom'
      )
    ,annotation=annotation(inferdata)
    ,protocolData=protocolData(inferdata)
  )
# Provider-wise data for prediction by causal factors,
# confirmed by IPW, and by medical histories
prediboth=
  ExpressionSet(
    assayData=
      rbind(
        exprs(predicause) %>%
          `rownames<-`(paste0('causal_',rownames(.)))
        ,exprs(predidata)
      )
    ,phenoData=phenoData(predidata)
    ,featureData=
      rbind(
        fData(predicause) %>%
          `rownames<-`(paste0('causal_',rownames(.)))
        ,fData(predidata)
      ) %>%
      AnnotatedDataFrame(varMetadata=fvarMetadata(predidata))
    ,experimentData=
      MIAME(
        name='Herdiantri Sufriyana'
        ,lab='Emily Chia-Yu Su Lab'
        ,contact='herdiantrisufriyana@unusa.ac.id'
        ,title='Medical history dataset for prediction'
        ,abstract=
          str_replace_all(
            'This dataset is a medical-history table from the BPJS Kesehatan.
            Selected causal factors, that is re-assigned by regex, are added.
            The target population is health insurance holders of 
            12-to-55-years-old females who visit healthcare providers between 
            2015 and 2016. The outcome of interest is prelabor rupture of 
            membrane (PROM). The medical history scenario is recorded
            individually within each healthcare provider nationwide.'
            ,'\n',' '
          ) %>%
          str_replace_all('\\s+',' ')
        ,url='https://github.com/herdiantrisufriyana/prom'
      )
    ,annotation=annotation(predidata)
    ,protocolData=protocolData(predidata)
  )
```

```{r Candidate predictors with non-zero variances, eval=FALSE, include=FALSE}
var_candidate_predictors=
  
  # Use only training set.
  prediboth %>%
  .[,pData(protocolData(.))$int] %>%
  
  # Get predictors and the outcome.
  lapply(X=1,Y=.,function(X,Y){
    exprs(Y) %>%
      t() %>%
      as.data.frame() %>%
      cbind(select(pData(Y),'outcome'))
  }) %>%
  .[[1]] %>%
  
  # Summarize a standard deviation for each predictor per outcome.
  select(outcome,everything()) %>%
  gather(key,value,-outcome) %>%
  group_by(key,outcome) %>%
  summarize(sd_value=sd(value,na.rm=T),.groups='drop') %>%
  arrange(factor(key,unique(key)),outcome) %>%
  spread(outcome,sd_value) %>%
  setNames(str_remove_all(names(.),'-')) %>% 
  arrange(factor(key,rownames(prediboth)[rownames(prediboth)%in%key]))
```

```{r Train-set-based NPS predictors excluding outcome leaker, include=FALSE}
# Select predictors without perfect separation problem.
if(run_heavy_computation){
  
  int_nps=
    prediboth %>%
    .[,pData(protocolData(.))$int] %>%
    extract_nps_mh() %>%
    arrange(factor(key,rownames(prediboth)[rownames(prediboth)%in%key]))
  
  saveRDS(int_nps,'data/int_nps.rds')
  
}else{
  int_nps=readRDS('data/int_nps.rds')
}

# Identify codes related to the end of pregnancy.
outcome_leaker=
  int_nps %>%
  left_join(rename(annotation,key=code),by='key') %>%
  filter(
    str_detect(
      str_to_lower(paste(key,desc))
      ,paste0(c(
        'abort'
        ,'deliver'
        ,'cesar'
        ,'labou?r\\s+'
        ,'natal'
        ,'postpartum'
        ,'terminat'
        ,'o0[0123]'
        ,'o152'
        ,'o364'
        ,'o63'
        ,'o7[02]'
        ,'o8[579]'
        ,'o90'
        ,'z3[79]'
      ),collapse='|')
    )
  ) %>%
  filter(!(
    str_detect(
      str_to_lower(paste(key,desc))
      ,paste0(c(
        'aborter'
        ,'ante'
        ,'peri'
        ,'delayed'
        ,'false'
        ,'failed'
        ,'prenatal'
        ,'threatened'
        ,'o311'
        ,'z351'
        ,'o600'
        ,'o96'
      ),collapse='|')
    ) &
    !str_detect(
      str_to_lower(key)
      ,paste0(c(
        'o0[34568]'
        ,'o15[12]'
        ,'o7[02]'
        ,'o8[79]'
      ),collapse='|')
    )
  )) %>%
  select(key,desc)

# Exclude the outcome-leaker codes.
int_nps_eol_p=
  int_nps %>%
  left_join(
    outcome_leaker %>%
      select(key) %>%
      mutate(excluded=1)
    ,by='key'
  ) %>%
  filter(is.na(excluded)) %>%
  select(-excluded)
```

```{r Non-zero variance and no perfect separation, eval=FALSE, include=FALSE}
var_candidate_predictors %>%
  
  # Exclude predictors that do not exist in training set.
  filter(!(nonevent==0 & event==0)) %>%
  
  # Join predictors without perfect separation problem.
  left_join(
    prediboth %>%
      .[,pData(protocolData(.))$int] %>%
      extract_nps_mh() %>%
      arrange(factor(key,rownames(prediboth)[rownames(prediboth)%in%key])) %>%
      mutate(perfect_separation='No')
    ,by=c('key','nonevent','event')
  ) %>%
  mutate(
    perfect_separation=
      ifelse(is.na(perfect_separation),'Yes',perfect_separation)
  ) %>%
  
  # Join combined annotation tables of medical histories and causal factors.
  left_join(
    rename(annotation,key=code) %>%
      rbind(
        dag$baseline_nodes %>%
          mutate(label=paste0('causal_',label)) %>%
          rename(desc=name,key=label) %>%
          select(key,desc)
      )
    ,by='key'
  ) %>%
  rename(candidate_predictor=key,description=desc) %>%
  setNames(str_to_title(colnames(.)) %>% str_replace_all('_',' ')) %>%
  
  kable() %>%
  kable_classic()
```

We excluded the diagnosis/procedure codes that may leak the outcome 
information. We only used the existing codes in the training set to determine 
outcome-leaker codes based on the previous codes for determining delivery or 
immediately after delivery care. There were 54 codes that may leak the outcome. 
All of them were also irredundant.

```{r Save outcome leakers, eval=FALSE, include=FALSE}
outcome_leaker %>%
  arrange(key) %>%
  rename(code=key,description=desc) %>%
  setNames(str_to_title(colnames(.))) %>%
  
  kable() %>%
  kable_classic()
```

```{r Correlations of candidate predictors, eval=FALSE, include=FALSE}
cor_predictors=
  
  # Use only training set.
  prediboth %>%
  .[,pData(protocolData(.))$int] %>%
  
  # Get predictors and the outcome.
  lapply(X=1,Y=.,function(X,Y){
    exprs(Y) %>%
      t() %>%
      as.data.frame() %>%
      cbind(select(pData(Y),'outcome'))
  }) %>%
  .[[1]] %>%
  
  # Get only predictors without perfect separation problem and not outcome leakers. 
  select(outcome,everything()) %>%
  mutate_all(function(x)ifelse(is.na(x),0,x)) %>%
  .[,int_nps_eol_p$key] %>%
  
  # Compute inter-predictor Pearson correlation coefficients.
  cor()
```

```{r Save and show the inter-predictor correlations, eval=FALSE, include=FALSE}
# Save the correlation coefficients.
cor_predictors %>%
  as.data.frame() %>%
  rownames_to_column(var=' ') %>%
  
  kable() %>%
  kable_classic()

# Show the correlation coefficients.
cor_predictors %>%
  
  # Remove auto-correlations.
  as.data.frame() %>%
  rownames_to_column(var='first') %>%
  gather(second,pearson_correlation_r,-first) %>%
  filter(first!=second) %>%
  
  # Remove redundant correlations.
  mutate(pair=seq(nrow(.))) %>%
  gather(order,predictor,-pair,-pearson_correlation_r) %>%
  group_by(pair) %>%
  arrange(pair,predictor) %>%
  mutate(order=c('first','second')) %>%
  ungroup() %>%
  spread(order,predictor) %>%
  select(-pair) %>%
  filter(!duplicated(.)) %>%
  
  # Filter the high-correlated pair of predictors.
  filter(pearson_correlation_r>0.7) %>%
  
  # Join regular expression of the coding components of causal factors 
  # to check if the high-correlated pairs are due to these components.
  left_join(
    baseline_nodes %>%
      mutate(label=paste0('causal_',label)) %>%
      rename(first=label) %>%
      select(first,name)
    ,by='first'
  ) %>%
  left_join(
    measure_nodes %>%
      mutate(label=paste0('causal_',str_remove_all(label,'\\*'))) %>%
      rename(regular_expression=name,first=label) %>%
      select(first,regular_expression)
    ,by='first'
  )
```

We also determined causal factors as the candidate predictors. These can be an 
example how to conduct the data transformation on a variable represented by 
multiple codes of diagnosis and procedure. We combined these factors with other 
variables that assign a single code.

```{r Save codes and demographics for causal factors, eval=FALSE, include=FALSE}
measure_nodes %>%
  
  # Get the regular expression to define causal factors.
  mutate(label=str_remove_all(label,'\\*')) %>%
  rename(regular_expression=name) %>%
  
  # Add the description.
  left_join(baseline_nodes,by='label') %>%
  filter(label!='Y01') %>%
  mutate(label=paste0('causal_',label)) %>%
  rename(causal_factor=name,variable=label) %>%
  select(causal_factor,variable,regular_expression) %>%
  
  # Based on the regular expression, gather the ICD-10 codes that apply.
  lapply(X=seq(nrow(.)),Y=.,function(X,Y){
    
    Z=Y$regular_expression[X]
    
    if(str_detect(Z,'\\(|\\)')){
      
      K=str_split(Z,'\\(|\\)')[[1]]
      
      L=K[2] %>%
        str_split('\\|') %>%
        .[[1]] %>%
        sapply(X=seq(length(.)),Y=.,Z=K[1],function(X,Y,Z){
          paste0(Z,Y[X])
        })
      
    }else{
      
      K=str_split(Z,'\\|')[[1]]
      
      L=K %>%
        lapply(X=seq(length(.)),Y=.,function(X,Y){
          if(str_detect(Y[X],'\\[|\\]')){
            
            Z=str_split(Y[X],'\\[|\\]')[[1]]
            
            if(str_detect(Z[2],'\\^')){
              
              K=Z[2] %>%
                str_remove_all('\\^')
              
              paste0(0:9,collapse='') %>%
                str_remove_all(K) %>%
                sapply(X=seq(str_count(.)),Y=.,Z=Z[1],function(X,Y,Z){
                  paste0(Z,str_sub(Y,X,X))
                })
              
            }else if(str_detect(Z[2],'\\-')){
              
              K=Z[2] %>%
                str_split_fixed('\\-',2)
              
              paste0(K[1]:K[2],collapse='') %>%
                sapply(X=seq(str_count(.)),Y=.,Z=Z[1],function(X,Y,Z){
                  paste0(Z,str_sub(Y,X,X))
                })
              
            }else{
              
              Z[2] %>%
                sapply(X=seq(str_count(.)),Y=.,Z=Z[1],function(X,Y,Z){
                  paste0(Z,str_sub(Y,X,X))
                })
              
            }
            
          }else{
            
            Y[X]
            
          }
        }) %>%
        unlist()
      
    }
    
    data.frame(
      causal_factor=Y$causal_factor[X]
      ,variable=Y$variable[X]
      ,regular_expression=Y$regular_expression[X]
      ,code=L
    )
    
  }) %>%
  do.call(rbind,.) %>%
  select(-regular_expression) %>%
  
  # Add information related to demographics.
  lapply(
    X=seq(nrow(.))
    ,Y=.
    ,Z=
      annotation %>%
      rbind(
        readRDS('data/cat_identity.rds') %>%
          mutate(
            code=
              desc %>%
              str_to_lower() %>%
              sapply(
                str_remove_all
                ,paste0(
                  c('age'
                    ,'householder'
                    ,str_replace_all(colnames(outcome),'_',' '))
                  ,collapse='|'
                )
              ) %>%
              str_to_upper() %>%
              trimws()
          )
      )
    ,function(X,Y,Z){
    
      Z %>%
        filter(str_detect(code,Y$code[X])) %>%
        mutate(
          causal_factor=Y$causal_factor[X]
          ,variable=Y$variable[X]
        )
  }) %>%
  do.call(rbind,.) %>%
  
  select(causal_factor,variable,everything()) %>%
  rename(demographics_or_medical_history=code,description=desc) %>%
  setNames(str_to_title(colnames(.)) %>% str_replace_all('_',' ')) %>%
  kable() %>%
  kable_classic()
```

We inferred the nationwide historical rates given the day number from a code 
encounter to current visit for each candidate predictor, as described in the 
main text. This used irredundant candidate predictors with non-zero variances 
and no perfect separation in training set only.

```{r Compute historical rate based on nationwide training set, include=FALSE}
if(run_heavy_computation){
  nw_int_hlin=
    inferboth %>%
    .[int_nps_eol_p$key
      ,pData(protocolData(.))$int] %>%
    trans_hist_rate(
      interpolation='linear'
      ,verbose=F
    )
  
  saveRDS(nw_int_hlin,'data/nw_int_hlin.rds')
}else{
  nw_int_hlin=readRDS('data/nw_int_hlin.rds')
}
```

```{r Use the nationwide rate to get it for whole prediction set, include=FALSE}
if(run_heavy_computation){
  pw_hlin=
    prediboth %>%
    .[int_nps_eol_p$key,] %>%
    trans_hist_rate(
      hist_rate=preproc(nw_int_hlin)$hist_rate
      ,interpolation='linear'
      ,verbose=F
    )
  
  saveRDS(pw_hlin,'data/pw_hlin.rds')
}else{
  pw_hlin=readRDS('data/pw_hlin.rds')
}
```

```{r Show the outcome and censoring in training set, eval=FALSE, include=FALSE}
pw_hlin %>%
  .[,pData(protocolData(.))$int] %>%
  pData() %>%
  select(outcome,censoring) %>%
  table()
```

## Step 2 to 4

The historical rates of all candidate predictors were fitted to a principal 
component (PC) model. Only derivation set was used for the model fitting. We 
applied 10-fold cross validation to estimate weights for all candidate 
predictors in each PC.

```{r Fit PC models with resampling based on train set, include=FALSE}
if(run_heavy_computation){
  pw_int_rsdr=
    pw_hlin %>%
    .[,pData(protocolData(.))$int] %>%
    exprs() %>%
    t() %>%
    as.data.frame() %>%
    rsdr(
      rs_method='CV'
      ,rs_number=10
      ,dr_method='PCA'
      ,cl=detectCores()/2
    )
  saveRDS(pw_int_rsdr,'data/pw_int_rsdr.rds')
}else{
  cat(readRDS('data/log.rds')[['pw_int_rsdr']])
  pw_int_rsdr=readRDS('data/pw_int_rsdr.rds')
}
```

## Step 5 to 6

Variable-wise average and standard deviation and weights of the transformation 
was estimated for those at population level by averaging values of the 
respective metrics. These values were inferred from training set only. 
Then, for either training or validation set, data were standardized and 
transformed into PCs.

```{r Prepare and combine PCs for all sets, eval=FALSE, include=FALSE}
# Transform any features into the PCs.
pw_pc=
  list('int','ran','geo','tem','bgt') %>%
  lapply(function(x){
    cat('For ',x,': ',sep='')
    pw_hlin %>%
      .[,pData(protocolData(.))[[x]]] %>%
      transformation(
        rsdr_object=pw_int_rsdr
        ,verbose=T
      )
  }) %>%
  setNames(c('int','ran','geo','tem','bgt'))
```

## Step 7

We computed the existing number of events per variable (EPV) before being 
transformed into PCs. Using original predictors, we only get 40 EPV. However, 
if 50 EPV is needed, then only 75 PC is warranted from 372. The PCs were sorted 
by proportion of variance explained (PVE) from the highest to the lowest. 
Eventually, we only selected top PCs in any subset. In this example, we 
demonstrated selecting PCs in training set.

```{r Compute EPV using train set and all PCs, eval=FALSE, include=FALSE}
pw_hlin %>%
  
  # Use pre-calibrated, training set.
  .[,pData(protocolData(.))$int] %>%
  pData() %>%
  
  # Summarize the number of censored and uncensored outcomes.
  select(outcome,censoring) %>%
  table() %>%
  as.numeric() %>%
  
  # Get the minimum uncensored number between event and nonevent.
  .[1:2] %>%
  min() %>%
  
  # Floor the number and divide it with the number of candidate features.
  lapply(X=1,Y=.,function(X,Y){
    floor(Y/nrow(pw_hlin))
  }) %>%
  .[[1]] %>%
  c(nrow(pw_hlin)) %>%
  setNames(c('EPV','Original predictors'))
```

```{r Compute maximum number of PCs to get 200 EPV, eval=FALSE, include=FALSE}
pw_hlin %>%
  
  # Use pre-calibrated, training set.
  .[,pData(protocolData(.))$int] %>%
  pData() %>%
  
  # Summarize the number of censored and uncensored outcomes.
  select(outcome,censoring) %>%
  table() %>%
  as.numeric() %>%
  
  # Get the minimum uncensored number between event and nonevent.
  .[1:2] %>%
  min() %>%
  
  # Floor the number and divide it with the number of candidate features.
  lapply(X=1,Y=.,function(X,Y){
    floor(Y/200)
  }) %>%
  .[[1]] %>%
  c(200) %>%
  setNames(c('PC','EPV'))
```

```{r Select the top PCs with highest PVE by training set, eval=FALSE, include=FALSE}
selected_pc=
  
  # Get PVE from the PC model and sort by PVE in descending order.
  pw_pc$int %>%
  preproc() %>%
  .$pve %>%
  sort(decreasing=T) %>%
  data.frame(PVE=.) %>%
  
  # Find the top-weight PCs up to the maximum number to get 200 EPV.
  slice(1:75) %>%
  rownames()
```

```{r Provider-wise training set for prediction by selected PCs, eval=FALSE, include=FALSE}
train_pw_pc=
  ExpressionSet(
    assayData=
      pw_pc %>%
      lapply(exprs) %>%
      do.call(cbind,.) %>%
      .[,colnames(pw_hlin)]
    ,phenoData=
      pw_pc %>%
      lapply(phenoData) %>%
      lapply(pData) %>%
      do.call(rbind,.) %>%
      `rownames<-`(str_split_fixed(rownames(.),'\\.',2)[,2]) %>%
      .[colnames(pw_hlin),] %>%
      AnnotatedDataFrame() %>%
      `varMetadata<-`(varMetadata(phenoData(pw_pc$int)))
    ,featureData=featureData(pw_pc$int)
    ,experimentData=
      MIAME(
        name='Herdiantri Sufriyana'
        ,lab='Emily Chia-Yu Su Lab'
        ,contact='herdiantrisufriyana@unusa.ac.id'
        ,title='Medical history PC dataset for prediction'
        ,abstract=
          str_replace_all(
            'This dataset is a medical-history table from the BPJS Kesehatan.
            Selected causal factors, that is re-assigned by regex, are added.
            All are transformed by resampled dimensional reduction using 
            principal components analysis with 10-fold cross validation (CV).
            The target population is health insurance holders of 
            12-to-55-years-old females who visit healthcare providers between 
            2015 and 2016. The outcome of interest is prelabor rupture of 
            membrane (PROM). The medical history scenario is recorded
            individually within each healthcare provider nationwide.'
            ,'\n',' '
          ) %>%
          str_replace_all('\\s+',' ')
        ,url='https://github.com/herdiantrisufriyana/prom'
      )
    ,annotation=annotation(pw_pc$int)
    ,protocolData=
      pw_pc %>%
      lapply(protocolData) %>%
      lapply(pData) %>%
      do.call(rbind,.) %>%
      `rownames<-`(str_split_fixed(rownames(.),'\\.',2)[,2]) %>%
      .[colnames(pw_hlin),] %>%
      AnnotatedDataFrame() %>%
      `varMetadata<-`(varMetadata(protocolData(pw_pc$int)))
  ) %>%
  .[selected_pc,]

gc()
```




































